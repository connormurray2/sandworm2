/**
 * Structure
 * =========
 *
 * A convenient structure to extend objects from that comes with very common
 * boiler plate instance methods:
 * - fromObject
 * - fromBr
 * - toBw
 * - fromBuffer
 * - fromFastBuffer
 * - toBuffer
 * - toFastBuffer
 * - fromHex
 * - toHex
 * - fromString
 * - toString
 * - fromJSON
 * - toJSON
 * - cloneByBuffer
 * - cloneByFastBuffer
 * - cloneByHex
 * - cloneByString
 * - cloneByJSON
 *
 * As well as static methods for:
 * - fromObject
 * - fromBr
 * - fromBuffer
 * - fromFastBuffer
 * - fromHex
 * - fromString
 * - fromJSON
 *
 * The "expect" method also facilitates deserializing a sequence of buffers
 * into an object.
 */
'use strict';

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.url.to-json");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Struct = void 0;

var _br = require("./br");

var _bw = require("./bw");

var _isHex = _interopRequireDefault(require("is-hex"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Struct {
  constructor(obj) {
    this.fromObject(obj);
  }

  fromObject(obj) {
    if (!obj) {
      return this;
    }

    for (const key of Object.keys(obj)) {
      if (obj[key] !== undefined) {
        this[key] = obj[key];
      }
    }

    return this;
  }

  static fromObject(obj) {
    return new this().fromObject(obj);
  }

  fromBr(br) {
    if (!(br instanceof _br.Br)) {
      throw new Error('br must be a buffer reader');
    }

    throw new Error('not implemented');
  }

  static fromBr(br) {
    return new this().fromBr(br);
  }

  asyncFromBr(br) {
    if (!(br instanceof _br.Br)) {
      throw new Error('br must be a buffer reader');
    }

    throw new Error('not implemented');
  }

  static asyncFromBr(br) {
    return new this().asyncFromBr(br);
  }

  toBw(bw) {
    throw new Error('not implemented');
  }

  asyncToBw(bw) {
    throw new Error('not implemented');
  }
  /**
     * It is very often the case that you want to create a bitcoin object from a
     * stream of small buffers rather than from a buffer of the correct length.
     * For instance, if streaming from the network or disk. The genFromBuffers
     * method is a generator which produces an iterator. Use .next(buf) to pass
     * in a small buffer. The iterator will end when it has received enough data
     * to produce the object. In some cases it is able to yield the number of
     * bytes it is expecting, but that is not always known.
     */


  *genFromBuffers() {
    throw new Error('not implemented');
  }
  /**
     * A convenience method used by from the genFromBuffers* generators.
     * Basically lets you expect a certain number of bytes (len) and keeps
     * yielding until you give it enough. It yields the expected amount
     * remaining, and returns an object containing a buffer of the expected
     * length, and, if any, the remainder buffer.
     */


  *expect(len, startbuf) {
    let buf = startbuf;
    const bw = new _bw.Bw();
    let gotlen = 0;

    if (startbuf) {
      bw.write(startbuf);
      gotlen += startbuf.length;
    }

    while (gotlen < len) {
      const remainderlen = len - gotlen;
      buf = yield remainderlen;

      if (!buf) {
        continue;
      }

      bw.write(buf);
      gotlen += buf.length;
    }

    buf = bw.toBuffer();
    const overlen = gotlen - len;
    const remainderbuf = buf.slice(buf.length - overlen, buf.length);
    buf = buf.slice(0, buf.length - overlen);
    return {
      buf: buf,
      remainderbuf: remainderbuf
    };
  }
  /**
     * Convert a buffer into an object, i.e. deserialize the object.
     */


  fromBuffer(buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('buf must be a buffer');
    }

    const br = new _br.Br(buf);

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    return this.fromBr(br, ...rest);
  }

  static fromBuffer() {
    return new this().fromBuffer(...arguments);
  }

  asyncFromBuffer(buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('buf must be a buffer');
    }

    const br = new _br.Br(buf);

    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    return this.asyncFromBr(br, ...rest);
  }

  static asyncFromBuffer(buf) {
    for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      rest[_key3 - 1] = arguments[_key3];
    }

    return new this().asyncFromBuffer(buf, ...rest);
  }
  /**
     * The complement of toFastBuffer - see description for toFastBuffer
     */


  fromFastBuffer(buf) {
    if (buf.length === 0) {
      return this;
    } else {
      for (var _len4 = arguments.length, rest = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        rest[_key4 - 1] = arguments[_key4];
      }

      return this.fromBuffer(buf, ...rest);
    }
  }

  static fromFastBuffer() {
    return new this().fromFastBuffer(...arguments);
  }
  /**
     * Convert the object into a buffer, i.e. serialize the object. This method
     * may block the main thread.
     */


  toBuffer() {
    return this.toBw(...arguments).toBuffer();
  }

  asyncToBuffer() {
    return this.asyncToBw(...arguments).then(bw => bw.toBuffer());
  }
  /**
     * Sometimes the toBuffer method has cryptography and blocks the main thread,
     * and we need a non-blocking way to serialize an object. That is what
     * toFastBuffer is. Of course it defaults to just using toBuffer if an object
     * hasn't implemented it. If your regular toBuffer method blocks, like with
     * Bip32, then you should implement this method to be non-blocking. This
     * method is used to send objects to the workers. i.e., for converting a
     * Bip32 object to a string, we need to encode it as a buffer in a
     * non-blocking manner with toFastBuffer, send it to a worker, then the
     * worker converts it to a string, which is a blocking operation.
     *
     * It is very common to want to convert a blank object to a zero length
     * buffer, so we can transport a blank object to a worker. So that behavior
     * is included by default.
     */


  toFastBuffer() {
    if (Object.keys(this).length === 0) {
      return Buffer.alloc(0);
    } else {
      return this.toBuffer(...arguments);
    }
  }

  fromHex(hex) {
    if (!(0, _isHex.default)(hex)) {
      throw new Error('invalid hex string');
    }

    const buf = Buffer.from(hex, 'hex');

    for (var _len5 = arguments.length, rest = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      rest[_key5 - 1] = arguments[_key5];
    }

    return this.fromBuffer(buf, ...rest);
  }

  static fromHex(hex) {
    for (var _len6 = arguments.length, rest = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      rest[_key6 - 1] = arguments[_key6];
    }

    return new this().fromHex(hex, ...rest);
  }

  asyncFromHex(hex) {
    if (!(0, _isHex.default)(hex)) {
      throw new Error('invalid hex string');
    }

    const buf = Buffer.from(hex, 'hex');

    for (var _len7 = arguments.length, rest = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
      rest[_key7 - 1] = arguments[_key7];
    }

    return this.asyncFromBuffer(buf, ...rest);
  }

  static asyncFromHex(hex) {
    for (var _len8 = arguments.length, rest = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
      rest[_key8 - 1] = arguments[_key8];
    }

    return new this().asyncFromHex(hex, ...rest);
  }

  fromFastHex(hex) {
    if (!(0, _isHex.default)(hex)) {
      throw new Error('invalid hex string');
    }

    const buf = Buffer.from(hex, 'hex');

    for (var _len9 = arguments.length, rest = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
      rest[_key9 - 1] = arguments[_key9];
    }

    return this.fromFastBuffer(buf, ...rest);
  }

  static fromFastHex(hex) {
    for (var _len10 = arguments.length, rest = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
      rest[_key10 - 1] = arguments[_key10];
    }

    return new this().fromFastHex(hex, ...rest);
  }

  toHex() {
    return this.toBuffer(...arguments).toString('hex');
  }

  asyncToHex() {
    return this.asyncToBuffer(...arguments).then(buf => buf.toString('hex'));
  }

  toFastHex() {
    return this.toFastBuffer(...arguments).toString('hex');
  }

  fromString(str) {
    if (typeof str !== 'string') {
      throw new Error('str must be a string');
    }

    for (var _len11 = arguments.length, rest = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
      rest[_key11 - 1] = arguments[_key11];
    }

    return this.fromHex(str, ...rest);
  }

  static fromString(str) {
    for (var _len12 = arguments.length, rest = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
      rest[_key12 - 1] = arguments[_key12];
    }

    return new this().fromString(str, ...rest);
  }

  asyncFromString(str) {
    if (typeof str !== 'string') {
      throw new Error('str must be a string');
    }

    for (var _len13 = arguments.length, rest = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
      rest[_key13 - 1] = arguments[_key13];
    }

    return this.asyncFromHex(str, ...rest);
  }

  static asyncFromString(str) {
    for (var _len14 = arguments.length, rest = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
      rest[_key14 - 1] = arguments[_key14];
    }

    return new this().asyncFromString(str, ...rest);
  }

  toString() {
    return this.toHex(...arguments);
  }

  asyncToString() {
    return this.asyncToHex(...arguments);
  }

  fromJSON(json) {
    throw new Error('not implemented');
  }

  static fromJSON(json) {
    for (var _len15 = arguments.length, rest = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
      rest[_key15 - 1] = arguments[_key15];
    }

    return new this().fromJSON(json, ...rest);
  }

  asyncFromJSON(json) {
    throw new Error('not implemented');
  }

  static asyncFromJSON(json) {
    for (var _len16 = arguments.length, rest = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
      rest[_key16 - 1] = arguments[_key16];
    }

    return new this().asyncFromJSON(json, ...rest);
  }

  toJSON() {
    var json = {};

    for (var val in this) {
      // arrays
      if (Array.isArray(this[val])) {
        const arr = [];

        for (var i in this[val]) {
          if (typeof this[val][i].toJSON === 'function') {
            arr.push(this[val][i].toJSON());
          } else {
            arr.push(JSON.stringify(this[val][i]));
          }
        }

        json[val] = arr; // objects
      } else if (this[val] === null) {
        json[val] = this[val];
      } else if (typeof this[val] === 'object' && typeof this[val].toJSON === 'function') {
        json[val] = this[val].toJSON(); // booleans, numbers, and strings
      } else if (typeof this[val] === 'boolean' || typeof this[val] === 'number' || typeof this[val] === 'string') {
        json[val] = this[val]; // buffers
      } else if (Buffer.isBuffer(this[val])) {
        json[val] = this[val].toString('hex'); // map
      } else if (this[val] instanceof Map) {
        json[val] = JSON.stringify(this[val]); // throw an error for objects that do not implement toJSON
      } else if (typeof this[val] === 'object') {
        throw new Error('not implemented');
      }
    }

    return json; // throw new Error('not implemented')
  }

  asyncToJSON() {
    throw new Error('not implemented');
  }

  clone() {
    // TODO: Should this be more intelligent about picking which clone method
    // to default to?
    return this.cloneByJSON();
  }

  cloneByBuffer() {
    return new this.constructor().fromBuffer(this.toBuffer());
  }

  cloneByFastBuffer() {
    return new this.constructor().fromFastBuffer(this.toFastBuffer());
  }

  cloneByHex() {
    return new this.constructor().fromHex(this.toHex());
  }

  cloneByString() {
    return new this.constructor().fromString(this.toString());
  }

  cloneByJSON() {
    return new this.constructor().fromJSON(this.toJSON());
  }

}

exports.Struct = Struct;