/**
 * Bitcoin Signed Message
 * ======================
 *
 * "Bitcoin Signed Message" just refers to a standard way of signing and
 * verifying an arbitrary message. The standard way to do this involves using a
 * "Bitcoin Signed Message:\n" prefix, which this code does. You are probably
 * interested in the static Bsm.sign( ... ) and Bsm.verify( ... ) functions,
 * which deal with a base64 string representing the compressed format of a
 * signature.
 */
'use strict';

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bsm = void 0;

var _address = require("./address");

var _bw = require("./bw");

var _cmp = require("./cmp");

var _ecdsa = require("./ecdsa");

var _hash = require("./hash");

var _keyPair = require("./key-pair");

var _sig = require("./sig");

var _struct = require("./struct");

var _workers = require("./workers");

class Bsm extends _struct.Struct {
  constructor(messageBuf, keyPair, sig, address, verified) {
    super({
      messageBuf,
      keyPair,
      sig,
      address,
      verified
    });
  }

  static magicHash(messageBuf) {
    if (!Buffer.isBuffer(messageBuf)) {
      throw new Error('messageBuf must be a buffer');
    }

    const bw = new _bw.Bw();
    bw.writeVarIntNum(Bsm.magicBytes.length);
    bw.write(Bsm.magicBytes);
    bw.writeVarIntNum(messageBuf.length);
    bw.write(messageBuf);
    const buf = bw.toBuffer();

    const hashBuf = _hash.Hash.sha256Sha256(buf);

    return hashBuf;
  }

  static async asyncMagicHash(messageBuf) {
    const args = [messageBuf];
    const workersResult = await _workers.Workers.asyncClassMethod(Bsm, 'magicHash', args);
    return workersResult.resbuf;
  }

  static sign(messageBuf, keyPair) {
    const m = new Bsm(messageBuf, keyPair);
    m.sign();
    const sigbuf = m.sig.toCompact();
    const sigstr = sigbuf.toString('base64');
    return sigstr;
  }

  static async asyncSign(messageBuf, keyPair) {
    const args = [messageBuf, keyPair];
    const workersResult = await _workers.Workers.asyncClassMethod(Bsm, 'sign', args);
    const sigstr = JSON.parse(workersResult.resbuf.toString());
    return sigstr;
  }

  static verify(messageBuf, sigstr, address) {
    const sigbuf = Buffer.from(sigstr, 'base64');
    const message = new Bsm();
    message.messageBuf = messageBuf;
    message.sig = new _sig.Sig().fromCompact(sigbuf);
    message.address = address;
    return message.verify().verified;
  }

  static async asyncVerify(messageBuf, sigstr, address) {
    const args = [messageBuf, sigstr, address];
    const workersResult = await _workers.Workers.asyncClassMethod(Bsm, 'verify', args);
    const res = JSON.parse(workersResult.resbuf.toString());
    return res;
  }

  sign() {
    const hashBuf = Bsm.magicHash(this.messageBuf);
    const ecdsa = new _ecdsa.Ecdsa().fromObject({
      hashBuf: hashBuf,
      keyPair: this.keyPair
    });
    ecdsa.sign();
    ecdsa.calcrecovery();
    this.sig = ecdsa.sig;
    return this;
  }

  verify() {
    const hashBuf = Bsm.magicHash(this.messageBuf);
    const ecdsa = new _ecdsa.Ecdsa();
    ecdsa.hashBuf = hashBuf;
    ecdsa.sig = this.sig;
    ecdsa.keyPair = new _keyPair.KeyPair();
    ecdsa.keyPair.pubKey = ecdsa.sig2PubKey();

    if (!ecdsa.verify()) {
      this.verified = false;
      return this;
    }

    const address = new _address.Address().fromPubKey(ecdsa.keyPair.pubKey, undefined, this.sig.compressed); // TODO: what if livenet/testnet mismatch?

    if ((0, _cmp.cmp)(address.hashBuf, this.address.hashBuf)) {
      this.verified = true;
    } else {
      this.verified = false;
    }

    return this;
  }

}

exports.Bsm = Bsm;
Bsm.magicBytes = Buffer.from('Bitcoin Signed Message:\n');