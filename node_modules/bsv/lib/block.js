/**
 * Block
 * =====
 *
 * A block, of course, is a collection of transactions. This class is somewhat
 * incompconste at the moment. In the future, it should support the ability to
 * check to see if a transaction is in a block (thanks to the magic of merkle
 * trees). You will probably never use Yours Bitcoin to create a block, since almost
 * everyone will use bitcoind for that. As such, the primary way to use this is
 * new Block().fromBuffer(buf), which will parse the block and prepare its insides
 * for you to inspect.
 */
'use strict';

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.dom-collections.iterator");

require("core-js/modules/web.url.to-json");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = void 0;

var _br = require("./br");

var _bw = require("./bw");

var _blockHeader = require("./block-header");

var _hash = require("./hash");

var _merkle = require("./merkle");

var _struct = require("./struct");

var _tx = require("./tx");

var _varInt = require("./var-int");

var _workers = require("./workers");

class Block extends _struct.Struct {
  constructor(blockHeader, txsVi, txs) {
    super({
      blockHeader,
      txsVi,
      txs
    });
  }

  fromJSON(json) {
    const txs = [];
    json.txs.forEach(function (tx) {
      txs.push(new _tx.Tx().fromJSON(tx));
    });
    this.fromObject({
      blockHeader: new _blockHeader.BlockHeader().fromJSON(json.blockHeader),
      txsVi: new _varInt.VarInt().fromJSON(json.txsVi),
      txs: txs
    });
    return this;
  }

  toJSON() {
    const txs = [];
    this.txs.forEach(function (tx) {
      txs.push(tx.toJSON());
    });
    return {
      blockHeader: this.blockHeader.toJSON(),
      txsVi: this.txsVi.toJSON(),
      txs: txs
    };
  }

  fromBr(br) {
    this.blockHeader = new _blockHeader.BlockHeader().fromBr(br);
    this.txsVi = new _varInt.VarInt(br.readVarIntBuf());
    const txsNum = this.txsVi.toNumber();
    this.txs = [];

    for (let i = 0; i < txsNum; i++) {
      this.txs.push(new _tx.Tx().fromBr(br));
    }

    return this;
  }

  toBw(bw) {
    if (!bw) {
      bw = new _bw.Bw();
    }

    bw.write(this.blockHeader.toBuffer());
    bw.write(this.txsVi.buf);
    const txsNum = this.txsVi.toNumber();

    for (let i = 0; i < txsNum; i++) {
      this.txs[i].toBw(bw);
    }

    return bw;
  }

  hash() {
    return _hash.Hash.sha256Sha256(this.blockHeader.toBuffer());
  }

  async asyncHash() {
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'hash', []);
    return workersResult.resbuf;
  }

  id() {
    return new _br.Br(this.hash()).readReverse().toString('hex');
  }

  async asyncId() {
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'id', []);
    return JSON.parse(workersResult.resbuf.toString());
  }

  verifyMerkleRoot() {
    const txsbufs = this.txs.map(tx => tx.toBuffer());

    const merkleRootBuf = _merkle.Merkle.fromBuffers(txsbufs).hash();

    return Buffer.compare(merkleRootBuf, this.blockHeader.merkleRootBuf);
  }
  /**
   * Sometimes we don't want to parse an entire block into memory. Instead, we
   * simply want to iterate through all transactions in the block. That is what
   * this method is for. This method returns an efficient iterator which can be
   * used in a `for (tx of txs)` construct that returns each tx one at a time
   * without first parsing all of them into memory.
   *
   * @param {Buffer} blockBuf A buffer of a block.
   */


  static iterateTxs(blockBuf) {
    const br = new _br.Br(blockBuf);
    const blockHeader = new _blockHeader.BlockHeader().fromBr(br);
    const txsVi = new _varInt.VarInt(br.readVarIntBuf());
    const txsNum = txsVi.toNumber();
    return {
      blockHeader,
      txsVi,
      txsNum,

      *[Symbol.iterator]() {
        for (let i = 0; i < txsNum; i++) {
          yield new _tx.Tx().fromBr(br);
        }
      }

    };
  }

}

exports.Block = Block;
Block.MAX_BLOCK_SIZE = 1000000;