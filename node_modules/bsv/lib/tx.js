/**
 * Transaction
 * ===========
 *
 * A bitcoin transaction.
 */
'use strict';

require("core-js/modules/es.array.sort");

require("core-js/modules/es.promise");

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.url.to-json");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tx = void 0;

var _bn = require("./bn");

var _br = require("./br");

var _bw = require("./bw");

var _ecdsa = require("./ecdsa");

var _hash = require("./hash");

var _hashCache = require("./hash-cache");

var _script = require("./script");

var _sig = require("./sig");

var _struct = require("./struct");

var _txIn = require("./tx-in");

var _txOut = require("./tx-out");

var _varInt = require("./var-int");

var _workers = require("./workers");

class Tx extends _struct.Struct {
  constructor() {
    let versionBytesNum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    let txInsVi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _varInt.VarInt.fromNumber(0);
    let txIns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let txOutsVi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _varInt.VarInt.fromNumber(0);
    let txOuts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    let nLockTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    super({
      versionBytesNum,
      txInsVi,
      txIns,
      txOutsVi,
      txOuts,
      nLockTime
    });
  }

  fromJSON(json) {
    const txIns = [];
    json.txIns.forEach(function (txIn) {
      txIns.push(new _txIn.TxIn().fromJSON(txIn));
    });
    const txOuts = [];
    json.txOuts.forEach(function (txOut) {
      txOuts.push(new _txOut.TxOut().fromJSON(txOut));
    });
    this.fromObject({
      versionBytesNum: json.versionBytesNum,
      txInsVi: new _varInt.VarInt().fromJSON(json.txInsVi),
      txIns: txIns,
      txOutsVi: new _varInt.VarInt().fromJSON(json.txOutsVi),
      txOuts: txOuts,
      nLockTime: json.nLockTime
    });
    return this;
  }

  toJSON() {
    const txIns = [];
    this.txIns.forEach(function (txIn) {
      txIns.push(txIn.toJSON());
    });
    const txOuts = [];
    this.txOuts.forEach(function (txOut) {
      txOuts.push(txOut.toJSON());
    });
    return {
      versionBytesNum: this.versionBytesNum,
      txInsVi: this.txInsVi.toJSON(),
      txIns: txIns,
      txOutsVi: this.txOutsVi.toJSON(),
      txOuts: txOuts,
      nLockTime: this.nLockTime
    };
  }

  fromBr(br) {
    this.versionBytesNum = br.readUInt32LE();
    this.txInsVi = new _varInt.VarInt(br.readVarIntBuf());
    const txInsNum = this.txInsVi.toNumber();
    this.txIns = [];

    for (let i = 0; i < txInsNum; i++) {
      this.txIns.push(new _txIn.TxIn().fromBr(br));
    }

    this.txOutsVi = new _varInt.VarInt(br.readVarIntBuf());
    const txOutsNum = this.txOutsVi.toNumber();
    this.txOuts = [];

    for (let i = 0; i < txOutsNum; i++) {
      this.txOuts.push(new _txOut.TxOut().fromBr(br));
    }

    this.nLockTime = br.readUInt32LE();
    return this;
  }

  toBw(bw) {
    if (!bw) {
      bw = new _bw.Bw();
    }

    bw.writeUInt32LE(this.versionBytesNum);
    bw.write(this.txInsVi.buf);

    for (let i = 0; i < this.txIns.length; i++) {
      this.txIns[i].toBw(bw);
    }

    bw.write(this.txOutsVi.buf);

    for (let i = 0; i < this.txOuts.length; i++) {
      this.txOuts[i].toBw(bw);
    }

    bw.writeUInt32LE(this.nLockTime);
    return bw;
  } // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md


  hashPrevouts() {
    const bw = new _bw.Bw();

    for (const i in this.txIns) {
      const txIn = this.txIns[i];
      bw.write(txIn.txHashBuf); // outpoint (1/2)

      bw.writeUInt32LE(txIn.txOutNum); // outpoint (2/2)
    }

    return _hash.Hash.sha256Sha256(bw.toBuffer());
  }

  hashSequence() {
    const bw = new _bw.Bw();

    for (const i in this.txIns) {
      const txIn = this.txIns[i];
      bw.writeUInt32LE(txIn.nSequence);
    }

    return _hash.Hash.sha256Sha256(bw.toBuffer());
  }

  hashOutputs() {
    const bw = new _bw.Bw();

    for (const i in this.txOuts) {
      const txOut = this.txOuts[i];
      bw.write(txOut.toBuffer());
    }

    return _hash.Hash.sha256Sha256(bw.toBuffer());
  }
  /**
   * For a normal transaction, subScript is usually the scriptPubKey. For a
   * p2sh transaction, subScript is usually the redeemScript. If you're not
   * normal because you're using OP_CODESEPARATORs, you know what to do.
   */


  sighash(nHashType, nIn, subScript, valueBn) {
    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let hashCache = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _hashCache.HashCache();

    // start with UAHF part (Bitcoin SV)
    // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
    if (nHashType & _sig.Sig.SIGHASH_FORKID && flags & Tx.SCRIPT_ENABLE_SIGHASH_FORKID) {
      let hashPrevouts = Buffer.alloc(32, 0);
      let hashSequence = Buffer.alloc(32, 0);
      let hashOutputs = Buffer.alloc(32, 0);

      if (!(nHashType & _sig.Sig.SIGHASH_ANYONECANPAY)) {
        hashPrevouts = hashCache.prevoutsHashBuf ? hashCache.prevoutsHashBuf : hashCache.prevoutsHashBuf = this.hashPrevouts();
      }

      if (!(nHashType & _sig.Sig.SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) !== _sig.Sig.SIGHASH_SINGLE && (nHashType & 0x1f) !== _sig.Sig.SIGHASH_NONE) {
        hashSequence = hashCache.sequenceHashBuf ? hashCache.sequenceHashBuf : hashCache.sequenceHashBuf = this.hashSequence();
      }

      if ((nHashType & 0x1f) !== _sig.Sig.SIGHASH_SINGLE && (nHashType & 0x1f) !== _sig.Sig.SIGHASH_NONE) {
        hashOutputs = hashCache.outputsHashBuf ? hashCache.outputsHashBuf : hashCache.outputsHashBuf = this.hashOutputs();
      } else if ((nHashType & 0x1f) === _sig.Sig.SIGHASH_SINGLE && nIn < this.txOuts.length) {
        hashOutputs = _hash.Hash.sha256Sha256(this.txOuts[nIn].toBuffer());
      }

      const bw = new _bw.Bw();
      bw.writeUInt32LE(this.versionBytesNum);
      bw.write(hashPrevouts);
      bw.write(hashSequence);
      bw.write(this.txIns[nIn].txHashBuf); // outpoint (1/2)

      bw.writeUInt32LE(this.txIns[nIn].txOutNum); // outpoint (2/2)

      bw.writeVarIntNum(subScript.toBuffer().length);
      bw.write(subScript.toBuffer());
      bw.writeUInt64LEBn(valueBn);
      bw.writeUInt32LE(this.txIns[nIn].nSequence);
      bw.write(hashOutputs);
      bw.writeUInt32LE(this.nLockTime);
      bw.writeUInt32LE(nHashType >>> 0);
      return new _br.Br(_hash.Hash.sha256Sha256(bw.toBuffer())).readReverse();
    } // original bitcoin code follows - not related to UAHF (Bitcoin SV)


    const txcopy = this.cloneByBuffer();
    subScript = new _script.Script().fromBuffer(subScript.toBuffer());
    subScript.removeCodeseparators();

    for (let i = 0; i < txcopy.txIns.length; i++) {
      txcopy.txIns[i] = _txIn.TxIn.fromBuffer(txcopy.txIns[i].toBuffer()).setScript(new _script.Script());
    }

    txcopy.txIns[nIn] = _txIn.TxIn.fromBuffer(txcopy.txIns[nIn].toBuffer()).setScript(subScript);

    if ((nHashType & 31) === _sig.Sig.SIGHASH_NONE) {
      txcopy.txOuts.length = 0;
      txcopy.txOutsVi = _varInt.VarInt.fromNumber(0);

      for (let i = 0; i < txcopy.txIns.length; i++) {
        if (i !== nIn) {
          txcopy.txIns[i].nSequence = 0;
        }
      }
    } else if ((nHashType & 31) === _sig.Sig.SIGHASH_SINGLE) {
      // The SIGHASH_SINGLE bug.
      // https://bitcointalk.org/index.php?topic=260595.0
      if (nIn > txcopy.txOuts.length - 1) {
        return Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
      }

      txcopy.txOuts.length = nIn + 1;
      txcopy.txOutsVi = _varInt.VarInt.fromNumber(nIn + 1);

      for (let i = 0; i < txcopy.txOuts.length; i++) {
        if (i < nIn) {
          txcopy.txOuts[i] = _txOut.TxOut.fromProperties(new _bn.Bn().fromBuffer(Buffer.from('ffffffffffffffff', 'hex')), new _script.Script());
        }
      }

      for (let i = 0; i < txcopy.txIns.length; i++) {
        if (i !== nIn) {
          txcopy.txIns[i].nSequence = 0;
        }
      }
    } // else, SIGHASH_ALL


    if (nHashType & _sig.Sig.SIGHASH_ANYONECANPAY) {
      txcopy.txIns[0] = txcopy.txIns[nIn];
      txcopy.txIns.length = 1;
      txcopy.txInsVi = _varInt.VarInt.fromNumber(1);
    }

    const buf = new _bw.Bw().write(txcopy.toBuffer()).writeInt32LE(nHashType).toBuffer();
    return new _br.Br(_hash.Hash.sha256Sha256(buf)).readReverse();
  }

  async asyncSighash(nHashType, nIn, subScript, valueBn) {
    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let hashCache = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'sighash', [nHashType, nIn, subScript, valueBn, flags, hashCache]);
    return workersResult.resbuf;
  } // This function returns a signature but does not update any inputs


  sign(keyPair) {
    let nHashType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _sig.Sig.SIGHASH_ALL | _sig.Sig.SIGHASH_FORKID;
    let nIn = arguments.length > 2 ? arguments[2] : undefined;
    let subScript = arguments.length > 3 ? arguments[3] : undefined;
    let valueBn = arguments.length > 4 ? arguments[4] : undefined;
    let flags = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Tx.SCRIPT_ENABLE_SIGHASH_FORKID;
    let hashCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
    const hashBuf = this.sighash(nHashType, nIn, subScript, valueBn, flags, hashCache);

    const sig = _ecdsa.Ecdsa.sign(hashBuf, keyPair, 'little').fromObject({
      nHashType: nHashType
    });

    return sig;
  }

  async asyncSign(keyPair) {
    let nHashType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _sig.Sig.SIGHASH_ALL | _sig.Sig.SIGHASH_FORKID;
    let nIn = arguments.length > 2 ? arguments[2] : undefined;
    let subScript = arguments.length > 3 ? arguments[3] : undefined;
    let valueBn = arguments.length > 4 ? arguments[4] : undefined;
    let flags = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Tx.SCRIPT_ENABLE_SIGHASH_FORKID;
    let hashCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'sign', [keyPair, nHashType, nIn, subScript, valueBn, flags, hashCache]);
    return new _sig.Sig().fromFastBuffer(workersResult.resbuf);
  } // This function takes a signature as input and does not parse any inputs


  verify(sig, pubKey, nIn, subScript) {
    let enforceLowS = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    let valueBn = arguments.length > 5 ? arguments[5] : undefined;
    let flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Tx.SCRIPT_ENABLE_SIGHASH_FORKID;
    let hashCache = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    const hashBuf = this.sighash(sig.nHashType, nIn, subScript, valueBn, flags, hashCache);
    return _ecdsa.Ecdsa.verify(hashBuf, sig, pubKey, 'little', enforceLowS);
  }

  async asyncVerify(sig, pubKey, nIn, subScript) {
    let enforceLowS = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    let valueBn = arguments.length > 5 ? arguments[5] : undefined;
    let flags = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Tx.SCRIPT_ENABLE_SIGHASH_FORKID;
    let hashCache = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'verify', [sig, pubKey, nIn, subScript, enforceLowS, valueBn, flags, hashCache]);
    return JSON.parse(workersResult.resbuf.toString());
  }

  hash() {
    return _hash.Hash.sha256Sha256(this.toBuffer());
  }

  async asyncHash() {
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'hash', []);
    return workersResult.resbuf;
  }

  id() {
    return new _br.Br(this.hash()).readReverse().toString('hex');
  }

  async asyncId() {
    const workersResult = await _workers.Workers.asyncObjectMethod(this, 'id', []);
    return JSON.parse(workersResult.resbuf.toString());
  }

  addTxIn(txHashBuf, txOutNum, script, nSequence) {
    let txIn;

    if (txHashBuf instanceof _txIn.TxIn) {
      txIn = txHashBuf;
    } else {
      txIn = new _txIn.TxIn().fromObject({
        txHashBuf,
        txOutNum,
        nSequence
      }).setScript(script);
    }

    this.txIns.push(txIn);
    this.txInsVi = _varInt.VarInt.fromNumber(this.txInsVi.toNumber() + 1);
    return this;
  }

  addTxOut(valueBn, script) {
    let txOut;

    if (valueBn instanceof _txOut.TxOut) {
      txOut = valueBn;
    } else {
      txOut = new _txOut.TxOut().fromObject({
        valueBn
      }).setScript(script);
    }

    this.txOuts.push(txOut);
    this.txOutsVi = _varInt.VarInt.fromNumber(this.txOutsVi.toNumber() + 1);
    return this;
  }
  /**
   * Analagous to bitcoind's IsCoinBase function in transaction.h
   */


  isCoinbase() {
    return this.txIns.length === 1 && this.txIns[0].hasNullInput();
  }
  /**
   * BIP 69 sorting. Be sure to sign after sorting.
   */


  sort() {
    this.txIns.sort((first, second) => {
      return new _br.Br(first.txHashBuf).readReverse().compare(new _br.Br(second.txHashBuf).readReverse()) || first.txOutNum - second.txOutNum;
    });
    this.txOuts.sort((first, second) => {
      return first.valueBn.sub(second.valueBn).toNumber() || first.script.toBuffer().compare(second.script.toBuffer());
    });
    return this;
  }

}

exports.Tx = Tx;
Tx.MAX_MONEY = 21000000 * 1e8; // This is defined on Interp, but Tx cannot depend on Interp - must redefine here

Tx.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;