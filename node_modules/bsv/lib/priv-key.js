/**
 * Private Key
 * ===========
 *
 * A private key is used for signing transactions (or messages). The primary
 * way to use this is new PrivKey().fromRandom(), or new PrivKey().fromBuffer(buf).
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrivKey = void 0;

var _bn = require("./bn");

var _point = require("./point");

var _constants = require("./constants");

var _base58Check = require("./base-58-check");

var _random = require("./random");

var _struct = require("./struct");

const DefaultConstants = _constants.Constants.Default.PrivKey;

class PrivKey extends _struct.Struct {
  constructor(bn, compressed) {
    let constants = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultConstants;
    super({
      bn,
      compressed
    });
    this.Constants = constants;
  }

  fromJSON(json) {
    this.fromHex(json);
    return this;
  }

  toJSON() {
    return this.toHex();
  }

  fromRandom() {
    let privBuf, bn, condition;

    do {
      privBuf = _random.Random.getRandomBuffer(32);
      bn = new _bn.Bn().fromBuffer(privBuf);
      condition = bn.lt(_point.Point.getN());
    } while (!condition);

    this.fromObject({
      bn: bn,
      compressed: true
    });
    return this;
  }

  static fromRandom() {
    return new this().fromRandom();
  }

  toBuffer() {
    let compressed = this.compressed;

    if (compressed === undefined) {
      compressed = true;
    }

    const privBuf = this.bn.toBuffer({
      size: 32
    });
    let buf;

    if (compressed) {
      buf = Buffer.concat([Buffer.from([this.Constants.versionByteNum]), privBuf, Buffer.from([0x01])]);
    } else {
      buf = Buffer.concat([Buffer.from([this.Constants.versionByteNum]), privBuf]);
    }

    return buf;
  }

  fromBuffer(buf) {
    if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
      this.compressed = true;
    } else if (buf.length === 1 + 32) {
      this.compressed = false;
    } else {
      throw new Error('Length of privKey buffer must be 33 (uncompressed pubKey) or 34 (compressed pubKey)');
    }

    if (buf[0] !== this.Constants.versionByteNum) {
      throw new Error('Invalid versionByteNum byte');
    }

    return this.fromBn(new _bn.Bn().fromBuffer(buf.slice(1, 1 + 32)));
  }

  toBn() {
    return this.bn;
  }

  fromBn(bn) {
    this.bn = bn;
    return this;
  }

  static fromBn(bn) {
    return new this().fromBn(bn);
  }

  validate() {
    if (!this.bn.lt(_point.Point.getN())) {
      throw new Error('Number must be less than N');
    }

    if (typeof this.compressed !== 'boolean') {
      throw new Error('Must specify whether the corresponding public key is compressed or not (true or false)');
    }

    return this;
  }
  /**
     * Output the private key a Wallet Import Format (Wif) string.
     */


  toWif() {
    return _base58Check.Base58Check.encode(this.toBuffer());
  }
  /**
     * Input the private key from a Wallet Import Format (Wif) string.
     */


  fromWif(str) {
    return this.fromBuffer(_base58Check.Base58Check.decode(str));
  }

  static fromWif(str) {
    return new this().fromWif(str);
  }

  toString() {
    return this.toWif();
  }

  fromString(str) {
    return this.fromWif(str);
  }

}

exports.PrivKey = PrivKey;
PrivKey.Mainnet = class extends PrivKey {
  constructor(bn, compressed) {
    super(bn, compressed, _constants.Constants.Mainnet.PrivKey);
  }

};
PrivKey.Testnet = class extends PrivKey {
  constructor(bn, compressed) {
    super(bn, compressed, _constants.Constants.Testnet.PrivKey);
  }

};