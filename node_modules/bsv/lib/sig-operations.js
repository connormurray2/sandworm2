/**
 * PubKey Map
 * ==========
 *
 * A map from (transaction hash, output number) to (script chunk index, pubKey).
 * Whening signing a bitcoin transaction, we need to be able to sign an input
 * with the correct key and also we need to know where to put signature when we
 * get it. This mapping allows us to find the key for an associated input (which
 * is identified by tx output hash and number) with which to sign the
 * transaction and then also to know where to insert the signature into the
 * input script. This gets us the public key, and we need a different method to
 * get the private key. That is because we often know the public key to be used
 * but may not have access to the private key until the entire tx is sent to
 * where the private keys are.
 */
'use strict';

require("core-js/modules/es.regexp.to-string");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SigOperations = void 0;

var _struct = require("./struct");

var _sig = require("./sig");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SigOperations extends _struct.Struct {
  constructor() {
    let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();
    super({
      map
    });
  }

  toJSON() {
    const json = {};
    this.map.forEach((arr, label) => {
      json[label] = arr.map(obj => ({
        nScriptChunk: obj.nScriptChunk,
        type: obj.type,
        // 'sig' or 'pubKey'
        addressStr: obj.addressStr,
        nHashType: obj.nHashType,
        log: obj.log
      }));
    });
    return json;
  }

  fromJSON(json) {
    Object.keys(json).forEach(label => {
      this.map.set(label, json[label].map(obj => ({
        scripChunkIndex: obj.nScriptChunk,
        type: obj.type,
        addressStr: obj.addressStr,
        nHashType: obj.nHashType,
        log: obj.log
      })));
    });
    return this;
  }
  /**
   * Set an address to in the map for use with single-sig.
   *
   * @param {Buffer} txHashBuf The hash of a transsaction. Note that this is
   * *not* the reversed transaction id, but is the raw hash.
   * @param {Number} txOutNum The output number, a.k.a. the "vout".
   * @param {Number} nScriptChunk The index of the chunk of the script where
   * we are going to place the signature.
   * @param {String} addressStr The addressStr coresponding to this (txHashBuf,
   * txOutNum, nScriptChunk) where we are going to sign and insert the
   * signature or public key.
   * @param {Number} nHashType Usually = Sig.SIGHASH_ALL | Sig.SIGHASH_FORKID
   */


  setOne(txHashBuf, txOutNum, nScriptChunk) {
    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'sig';
    let addressStr = arguments.length > 4 ? arguments[4] : undefined;
    let nHashType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _sig.Sig.SIGHASH_ALL | _sig.Sig.SIGHASH_FORKID;
    const label = txHashBuf.toString('hex') + ':' + txOutNum;
    const obj = {
      nScriptChunk,
      type,
      addressStr,
      nHashType
    };
    this.map.set(label, [obj]);
    return this;
  }
  /**
   * Set a bunch of addresses for signing an input such as for use with multi-sig.
   *
   * @param {Buffer} txHashBuf The hash of a transsaction. Note that this is
   * *not* the reversed transaction id, but is the raw hash.
   * @param {Number} txOutNum The output number, a.k.a. the "vout".
   * @param {Array} arr Must take the form of [{nScriptChunk, type, addressStr, nHashType}, ...]
   */


  setMany(txHashBuf, txOutNum, arr) {
    const label = txHashBuf.toString('hex') + ':' + txOutNum;
    arr = arr.map(obj => _objectSpread({
      type: obj.type || 'sig',
      nHashType: obj.nHashType || _sig.Sig.SIGHASH_ALL | _sig.Sig.SIGHASH_FORKID
    }, obj));
    this.map.set(label, arr);
    return this;
  }

  addOne(txHashBuf, txOutNum, nScriptChunk) {
    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'sig';
    let addressStr = arguments.length > 4 ? arguments[4] : undefined;
    let nHashType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _sig.Sig.SIGHASH_ALL | _sig.Sig.SIGHASH_FORKID;
    const arr = this.get(txHashBuf, txOutNum) || [];
    arr.push({
      nScriptChunk,
      type,
      addressStr,
      nHashType
    });
    this.setMany(txHashBuf, txOutNum, arr);
    return this;
  }
  /**
   * Get an address from the map
   *
   * @param {Buffer} txHashBuf The hash of a transction. Note that this is *not*
   * the reversed transaction id, but is the raw hash.
   * @param {Number} txOutNum The output number, a.k.a. the "vout".
   * @param {Number} nScriptChunk The index of the chunk of the script where
   * we are going to place the signature.
   * @returns {PubKey}
   */


  get(txHashBuf, txOutNum) {
    const label = txHashBuf.toString('hex') + ':' + txOutNum;
    return this.map.get(label);
  }

}

exports.SigOperations = SigOperations;